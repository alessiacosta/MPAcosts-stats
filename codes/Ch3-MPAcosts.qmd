---
title: "Ch3-MPAcosts"
---

# Loading packages needed for the project

```{r}
library(readr)
library(ggplot2)
library(rnaturalearth) # to make a world map
library(rnaturalearthdata) # data for world map with polygons of the coastline only
library(dplyr)
library(sf)
library(ggspatial) # to add spatial elements to a ggplot map
library(car)
library(cmdstanr)      #for cmdstan
library(brms)          #for fitting models in STAN
library(coda)          #for diagnostics
library(bayesplot)     #for diagnostics
library(DHARMa)        #for residual diagnostics
library(rstan)         #for interfacing with STAN
library(emmeans)       #for marginal means etc
library(broom)         #for tidying outputs
library(tidybayes)     #for more tidying outputs
library(ggeffects)     #for partial plots
library(broom.mixed)   #for summarising models
library(ggeffects)     #for partial effects plots
library(bayestestR)    #for ROPE
library(see)           #for some plots
library(patchwork)     #for multiple plots
library(modelsummary)  #for data and model summaries 
library(ggridges)      #for ridge plots 
library(stringr)
library(tidyr)
library(purrr)
library(HDInterval)
library(tibble)
library(geoR)
library(scales)       #for scientific notation on axes
library(forcats)      #for factor manipulation
#sourcing functions from Murray's github repository
source('helperFunctions.R')
```

# Making a map of the MPAs found

## Loading the map data

```{r}
#upload the right data
fig1 <- read_csv("../Data/fig.1.csv")
```

## Making global map with my data

```{r}
# Get world map data
world <- ne_countries(scale = "medium", returnclass = "sf")

png("Map1.png", width = 2500, height = 2000, res = 150)
# Create the world map
# Load the coastline data from rnaturalearth
coastline_data <- ne_coastline(scale = "medium", returnclass = "sf")

# Create the plot
ggplot() +  
  # Plot countries in a very light grey
  geom_sf(data = world, fill = "grey95", color = NA) +  
  # Overlay the coastline in black
  geom_sf(data = coastline_data, color = "black", fill = NA) +  
  # Plot your data points
  geom_point(data = fig1, aes(x = Longitude, y = Latitude), color = "#0F4D92", size = 5) +  # color #008080 #3B7CA3
  # Set coordinate system
  coord_sf() +
  # Adjust theme
  theme_minimal() +  
  theme(
    axis.text = element_text(size = 24),
    axis.title = element_blank(),  # Removes axis titles
    axis.line.x = element_line(color = "black", size = 0.5),
    axis.line.y = element_line(color = "black", size = 0.5),
    axis.ticks = element_line(color = "black", size = 0.5),
    panel.grid = element_blank()
  )
dev.off()

```
```{r}
# Get world map data
world <- ne_countries(scale = "medium", returnclass = "sf")

png("Philippines.png", width = 2500, height = 2000, res = 150)
# Create the world map
# Load the coastline data from rnaturalearth
coastline_data <- ne_coastline(scale = "medium", returnclass = "sf")

# Create the plot
ggplot() +  
  # Plot countries in a very light grey
  geom_sf(data = world, fill = "grey95", color = NA) +  
  # Overlay the coastline in black
  geom_sf(data = coastline_data, color = "black", fill = NA) +  
  # Plot your data points
  geom_point(data = fig1, aes(x = Longitude, y = Latitude), color = "goldenrod1", size = 8) +  # color #008080
  # Set coordinate system
  coord_sf() +
  #set the corrdinate to cover philippines only
  xlim(117, 130) +
  ylim(4, 22) +
  # Adjust theme
  theme_minimal() +  
  theme(
    axis.text = element_text(size = 24),
    axis.title = element_blank(),  # Removes axis titles
    axis.line.x = element_line(color = "black", size = 0.5),
    axis.line.y = element_line(color = "black", size = 0.5),
    axis.ticks = element_line(color = "black", size = 0.5),
    panel.grid = element_blank())
dev.off()
```


# Statistics

## Bayesian regression with Gamma distribution - establishment

#### Data preparation

```{r}
#importing establishment data
esubs <- read_csv("../Data/esubs.csv")
View(esubs)
#removing the last two rows from the dataset cause for some reason it pops up as NAs
#esubs <- head(esubs, -2)
#View(esubs)

#data preparation
#esubs = esubs |> 
  #mutate(Protection_level=factor(Protection_level, 
   #                                             levels=c("Fully protected", "Partially protected")), 
    #     ID=factor(ID)) # this will order them rather than going into alphabetical order 
#View(esubs)
#summary(esubs)

```

#### Exploratory data analysis

```{r}
# Data exploration to see what distribution I can use in the model
#looking at distribution for costs/km2 divided by gdp classc
esubs |> ggplot(aes(y=Cost_km)) +
  geom_boxplot()
#making an histogram 
esubs |> ggplot(aes(x=Cost_km)) +
  geom_histogram()

#logging the data before producing the histgram 
esubs |> ggplot(aes(x=log(Cost_km))) +
  geom_histogram()

#logging the axis
esubs |> ggplot(aes(x=Cost_km)) +
  geom_histogram() +
  scale_x_log10()
#preferable to change the axis scale and not change the data, in case of raw data it does not make much difference

#checking for linearity 
esubs |> ggplot(aes(y=Cost_km, x=Years)) +
  geom_point() +
  geom_line(aes(group=ID))
# need this to be more clear to see what whether there are patterns

#making a facet 
esubs |> ggplot(aes(y=Cost_km, x=Years)) +
  geom_point() +
  geom_smooth(method="lm") +
  facet_wrap(~ID)

#checking relationship between size and gdp
ggplot() +
  geom_point(data=esubs, aes(x=Size, y=Cost_km)) +
  geom_smooth(data=esubs, aes(x=Size, y=Cost_km), method="lm") +
  labs(x="Size (km²)", y="Establishment cost/km²")

#checking distribution of mpa size
hist(log(esubs$Size), nclass=75)
```

#### Fit the model

```{r}
#starting setting up the model
#model formula
esubs <- esubs |> 
  mutate(lSize=log(Size), 
         lCost_km=log(Cost_km))

#form1 = bf(lCost_km ~ scale(lSize) + scale(Years) + scale(GDP_pc) + Protection_level, family=gaussian()) # there is correlation between size and gdp
#correlation is too high to be able to include gdp or size in the model, however we can say that size explains more of the variance so we can use size size as a proxy for the gdp and only include the size in the model
form1 = bf(lCost_km ~ scale(lSize) + scale(Years) + Protection_level, family=gaussian)
#View(esubs)
# mean for each group and mads for each group for our priors
esubs |> group_by(Protection_level) |>
  summarise(Median=median(lCost_km), MAD=mad(lCost_km))
  
#looking at priors needed
get_prior(form1, esubs)

#setting my priors
priors = prior(normal(11, 1.8), class='Intercept') +
  prior(normal(0,1.8), class='b')

# running the model with priors only
esubs.brm1 = brm(form1, 
               data=esubs, 
               prior=priors,
               sample_prior='only', 
               iter= 5000, 
               warmup = 1000, 
               chains=3, 
               cores = 3, 
               thin=5, 
               refresh=0, 
               seed=123, 
               control = list(adapt_delta=0.99, max_treedepth=29),
               backend = "cmdstanr")

#making a conditional plot
esubs.brm1 |>
  conditional_effects() |> 
  plot(points=TRUE)

#making a conditional plot on a better scale 
esubs.brm1 |>
  conditional_effects() |> 
  plot(points=TRUE) |> 
  wrap_plots() &
  scale_y_log10() # I had to increase the priors because they were not wide enough

# running the model with both priors and data
esubs.brm2 = esubs.brm1 |> 
  update(sample_prior = 'yes', refresh=100)
#Assess priors and posteriors
esubs.brm2 |> SUYR_prior_and_posterior()

#Produce the same conditional plot but with the posteriors
esubs.brm2 |>
  conditional_effects() |> 
  plot(points=TRUE) |> 
  wrap_plots() # &
  #scale_y_log10()
#priors are not influential but there is very little data
```

#### MCMC sampling diagnostics

```{r}
#trace plot 
esubs.brm2$fit |> stan_trace()

#border correlarion
esubs.brm2$fit |> stan_ac()

#chain convergence
esubs.brm2$fit |> stan_rhat()
#all values less than 1.01

#effective sample size
esubs.brm2$fit |> stan_ess() # there are no issues here
#values higher than 0.5 and as close to 1 as possible, otherwise it means that the sampler drifted away

#check the densities
esubs.brm2$fit |> stan_dens(separate_chains=TRUE)
#this plot is good if we have high hats 

```

#### Model validation

```{r}
#probability check
esubs.brm2 |> pp_check(type='dens_overlay', ndraws=100)
#not the best fit it could be 

#sim residuals 
esubs.resids  = make_brms_dharma_res(esubs.brm2, integerResponse= TRUE)
testUniformity(esubs.resids)
#simulated residuals are not too bad, acceptable

#check no patterns in the residuals 
plotResiduals(esubs.resids, quantreg = TRUE)
#no issues here, looks half decent
#the diagnostics look fine but we know we need to check other things based on the pp check

#test for correlation 
hist(esubs$Cost_km, nclass=75)
hist(log(esubs$Cost_km), nclass=75)
plot(esubs$lCost_km~esubs$GDP_pc)
cor(esubs$lSize, esubs$GDP_pc)
cor(esubs$Years, esubs$GDP_pc, use = "complete.obs")
cor(esubs$Years, esubs$lSize, use = "complete.obs")
library(corrplot)
corrplot(esubs[,c("Years", "lSize", "lCost_km", "GDP_pc")], method="circle")

```

#### Results

```{r}
# generic summary 
esubs.brm2 |> summary() 

#thorough results
esubs.brm2 |> 
  as_draws_df() |>  
  dplyr::select(matches("^b_.*")) |> 
  summarise_draws(
    median=~exp(median(.x)), 
    hdi = ~HDInterval::hdi(exp(.x)),
    rhat, 
    ess_bulk,
    Pl=~mean(.x<0), 
    Pg=~mean(.x>0))

#Paritally protected (0.062-1)*100= -93% decresase in cost_km in partially protected areas than in fully protected areas, and we have strong evidence because we look a Pl for evidence- 99%

#the amount of variability explained by the model -quasi R sqaured
esubs.brm2 |> bayes_R2(summary=FALSE) |> median_hdci()
#we are explaining 40% of the variance with this model -  which should be a pretty good fit for the model
```

#### Plot results - predictions

```{r}
#backtrnasformed the response variable to identity (or absolute values) as well as intervals 
pred_draws <- emmeans(
  esubs.brm2,
  ~ lSize,
  at = list(
    lSize = seq(min(esubs$lSize), max(esubs$lSize), length.out = 100),
    Years = mean(esubs$Years, na.rm = TRUE)
  )
) |>
  gather_emmeans_draws() |>
  mutate(.value = exp(.value))  # back-transform from log

# Now safely summarise per lSize using purrr
pred_size <- pred_draws |>
  group_split(lSize) |>
  map_dfr(function(df) {
    hdi_vals <- hdi(df$.value)
    tibble(
      lSize     = unique(df$lSize),
      median    = median(df$.value),
      lower.HPD = hdi_vals[1],
      upper.HPD = hdi_vals[2]
    )
  })

#View(pred_size)
#producing a predicted ggplot
  lesize = 
  ggplot(pred_size, aes(x = lSize, y = median)) +
  geom_line(size = 0.8) +  # thinner line
  geom_point(data=esubs, aes(x=lSize, y=Cost_km)) + 
  geom_ribbon(aes(ymin = lower.HPD, ymax = upper.HPD), alpha = 0.2, color = NA) +
  theme_bw() +
  theme(text = element_text(family = "serif", size=7),
        axis.title = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()) +
  scale_y_log10(
      labels = label_scientific(),
      limits = c(1e0, 1e07))
  
nesize = 
  ggplot(pred_size, aes(x = lSize, y = median)) +
  geom_line(size = 0.8) +  # thinner line
  geom_ribbon(aes(ymin = lower.HPD, ymax = upper.HPD), alpha = 0.2, color = NA) +
  theme_bw() +
  theme(text = element_text(family = "serif")) + 
  scale_y_continuous(
    labels = label_scientific(),
    limits = c(0, 1.0e+06)  # forces the axis to go up to 1e6
  ) +
  labs(
    x = "lnSize (km²)",
    y = "Estimated establishment costs (cost/km²)"
  )

 #Combine and export the inset
png("establishment size.png", width = 1500, height = 1000, res = 300) 
#final_plot <- 
esize = 
nesize + 
  inset_element(
    lesize,
    left = 0.25,
    bottom = 0.45,
    right = 0.98,
    top = 0.95
  )
dev.off()

# Generate prediction data
#remove nas from the data
esubs <- esubs |> 
  filter(!is.na(Years)) 

pred_draws1 <- emmeans(
  # This is the fitted Bayesian model object, likely of class 'brmsfit' (e.g., from the 'brms' package)
  esubs.brm2,
  # This formula specifies that we want to compute marginal means over the variable 'Years'
  ~ Years,
  # This 'at' argument defines the values of the predictors at which to compute the EMMs
  at = list(
    # Create a sequence of 100 evenly spaced values between the minimum and maximum of 'Years'
    Years = seq(min(esubs$Years), max(esubs$Years), length.out = 100),
    # Set the value of 'lSize' to its mean (excluding NAs) for marginalization purposes
    lSize = mean(esubs$lSize, na.rm = TRUE))) |>
  # Extract the posterior draws of the marginal means
  # 'gather_emmeans_draws()' is from the 'tidybayes' package and converts EMM output to a tidy format,
  # preserving the full set of posterior samples for each marginal mean
  gather_emmeans_draws() |>
  # Transform the predicted values (assumed to be on the log scale) back to the original scale
  # If the model used a log-link function, we exponentiate the predicted values to get them on the response scale
  mutate(.value = exp(.value))

# This line takes the 'pred_draws1' data frame and pipes it through a series of transformations
pred_size1 <- pred_draws1 |>
  # First, it splits the data frame into a list of data frames by the 'Years' column.
  # Each element in the resulting list contains rows corresponding to one year.
  group_split(Years) |>
  # Then, for each data frame (corresponding to a year), the anonymous function is applied.
  # The 'map_dfr()' function from the 'purrr' package maps the function over the list,
  # and returns a single combined data frame by row-binding all the results.
  map_dfr(function(df) {
    # Calculate the highest density interval (HDI) for the '.value' column in the current data frame.
    # 'hdi()' returns the lower and upper bounds of the HDI.
    hdi_vals <- hdi(df$.value)
    # Return a new tibble (a tidy data frame) containing:
    tibble(
      # The unique year for this subset of data
      Years    = unique(df$Years),
      # The median of the posterior draws (or sampled values) for this year
      median    = median(df$.value),
      # The lower bound of the 95% Highest Posterior Density interval (or HPDI)
      lower.HPD = hdi_vals[1],
      # The upper bound of the HPDI
      upper.HPD = hdi_vals[2]
    )
  })
#View(pred_size1)

#plot prediction
 lyears = 
   ggplot(pred_size1, aes(x = Years, y = median)) +
  geom_line(size = 0.8) +  # thinner line
  geom_point(data =esubs, aes(x=Years, y=Cost_km)) +
  geom_ribbon(aes(ymin = lower.HPD, ymax = upper.HPD), alpha = 0.2, color = NA) +
     scale_y_continuous(labels = label_scientific()) +  # Scientific notation on y-axis
  theme_bw() +
     scale_y_log10() + # Logarithmic scale for y-axis
   theme(text = element_text(family = "serif", size=7),
         axis.title = element_blank(),
         # These lines remove the grid
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank())
 nyears=
      ggplot(pred_size1, aes(x = Years, y = median)) +
  geom_line(size = 0.8) +  # thinner line
  geom_ribbon(aes(ymin = lower.HPD, ymax = upper.HPD), alpha = 0.2, color = NA) +
     scale_y_continuous(labels = label_scientific()) +  # Scientific notation on y-axis
  theme_bw() +
   theme(text = element_text(family = "serif")) +
  labs(
    x = "Establishment phase (years)",
    y = "Estimated establishment cost ($/km²)")

 #Combine and export the inset
png("years.png", width = 1300, height = 1400, res = 300) 
#final_plot <- 
  nyears +
  inset_element(
    lyears,
    left = 0.02, 
    bottom = 0.55,
    right = 0.65,
    top = 0.95)
dev.off()

```

## Bayesian regression with Gamma distribution - maintenance with subs

#### Data preparation

```{r}
#using maintenance coded with subs 
msubs <- read_csv("../Data/msubs.csv")
#View(msubs)
#preparing data
#msubs = msubs |> mutate(Protection_level=factor(Protection_level, 
 #                                               levels=c("Fully protected", "Partially protected")), 
  #                      Cost_class=factor(Cost_class))#, # this will order them rather than going into a
summary(msubs)

#Adding a new column for protection level and code it as a as binary --> 1 as fully protected and 0 for partially protected
msubs$Protection_bin<-msubs$Enforcement*NA
msubs$Protection_bin[msubs$Protection_level=="Fully protected"]<-1
msubs$Protection_bin[msubs$Protection_level=="Partially protected"]<-0

#making a subset for each cost class, maitenance, management, administration and enfircement 
msubs <- msubs |>  
 subset(Cost_class %in% c("Maintenance"))
summary(msubs) 
hist(log(msubs$Cost_km), nclass=75)

#table(as.numeric(msubs$Cost_km),msubs$Cost_class)

```

#### Exploratory data analysis

```{r}
#View(msubs)
## Data exploration to see what distribution I can use in the model
#looking at distribution for costs/km2 divided by gdp classc
msubs |> ggplot(aes(y=Cost_km)) +
  geom_boxplot()
#making an histogram 
msubs |> ggplot(aes(x=Cost_km)) +
  geom_histogram()

#logging the data before producing the histgram 
msubs |> ggplot(aes(x=log(Cost_km))) +
  geom_histogram()

#logging the axis
msubs |> ggplot(aes(x=Cost_km)) +
  geom_histogram() +
  scale_x_log10()
#preferable to change the axis scale and not change the data, in case of raw data it does not make much difference

#checking for linearity 
msubs |> ggplot(aes(y=Cost_km, x=Size)) +
  geom_point() +
  geom_line(aes(group=ID))
# need this to be more clear to see what whether there are patterns

#making a facet 
esubs |> ggplot(aes(y=Cost_km, x=Size)) +
  geom_point() +
  geom_smooth(method="lm") +
  facet_wrap(~Protection_level)
```

#### Fit the model

```{r}
#standardising the cost_km into smaller values
msubs<- msubs |> 
   mutate(lCost_km=log(Cost_km)) |> 
  mutate(lSize=log(Size))
#model formula 
#by keeping the intercept at 0 we are forciing the relationship for which maitenance is a combination of management, administration and enforcement, #similarly by scaling the binary coded the protection level we are forcing the model to use the mean of the protection level --> an average MPAs (whatever that is)
form = bf(lCost_km ~ scale(lSize) + scale(GDP_pc) + Protection_level, family=gaussian)
# mean for each group and mads for each group for our priors
msubs |> 
  group_by(Protection_level) |>
  summarise(Median=median(lCost_km), MAD=mad(lCost_km))

#getting standard priors
get_prior(form, data=msubs)

#setting priors
priors = prior(normal(9, 1), class='Intercept') +
  prior(normal(0,1), class='b') #within brackets add lb=0

# running the model with priors only
msubs.brm1 = brm(form, 
               data=msubs, 
               prior=priors,
               sample_prior='only', 
               iter= 5000, 
               warmup = 1000, 
               chains=3, 
               cores = 3, 
               thin=5, 
               refresh=0, 
               seed=123, 
               control = list(adapt_delta=0.99, max_treedepth=15),
               backend = "cmdstanr")

#making a conditional plot
msubs.brm1 |>
  conditional_effects() |> 
  plot(points=TRUE, ask=FALSE, plot=FALSE) |> 
  wrap_plots() &
  scale_y_log10()

# running the model with both priors and data
msubs.brm2 = msubs.brm1 |> 
  update(sample_prior = 'yes', refresh=0)
#Assess priors and posteriors
msubs.brm2 |> SUYR_prior_and_posterior() # this does not run because i hano intercept in the model 
#Produce the same conditional plot but with the posteriors
msubs.brm2 |>
  conditional_effects() |> 
  plot(points=TRUE) |> 
  wrap_plots()
```

#### MCMC sampling diagnostics

```{r}
#trace plot 
msubs.brm2$fit |> stan_trace()

#border correlarion
msubs.brm2$fit |> stan_ac()

#chain convergence
msubs.brm2$fit |> stan_rhat()

#effective sample size
msubs.brm2$fit |> stan_ess() # there are no issues here

#check the densities
msubs.brm2$fit |> stan_dens(separate_chains=TRUE)
#this plot is good if we have high hats 
```

#### Model validation

```{r}
#probability check
msubs.brm2 |> pp_check(type='dens_overlay', ndraws=100) 
#not the best fit it could be 

#sim residuals 
msubs.resids  = make_brms_dharma_res(msubs.brm2, integerResponse= TRUE)
testUniformity(msubs.resids)
#simulated residuals are not too bad, acceptable

#check no patterns in the residuals 
plotResiduals(msubs.resids, quantreg = TRUE)
#red lines that there might be some trends occurring, because the line is high and it decreases. 
#without lines we would have not noticed the trends
```

#### Results

```{r}
# generic summary 
msubs.brm2 |> summary()

#thorough results
msubs.brm2 |> 
  as_draws_df() |>  
  dplyr::select(matches("^b_.*")) |> 
  summarise_draws(median=~exp(median(.x)), 
                  hdi = ~HDInterval::hdi(exp(.x)),
                  rhat, 
                  ess_bulk,
                  Pl=~mean(.x<0), 
                  Pg=~mean(.x>0))
#Partially protected (1-0.062)*100= 93% decresase in cost_km in partially protected areas than in fully protected areas, and we have strong evidence because we look a Pl for evidence- 99%

#the amount of variability explained by the model -quasi R sqaured
msubs.brm2 |> bayes_R2(summary=FALSE) |> median_hdci()
#we are explaining 10% of the variance with this model -  which should be a pretty good fit for the model
```

#### Plot results - predictions

```{r}
#prediction of the maintenance costs/km2 per year
pred_draws_m <- emmeans(
  msubs.brm2,
  ~ lSize,
  at = list(
    lSize = seq(min(msubs$lSize), max(msubs$lSize), length.out = 100),
    GDP_pc = mean(msubs$GDP_pc, na.rm = TRUE)
  )
) |>
  gather_emmeans_draws() |>
  mutate(.value = exp(.value))  # back-transform from log

# Now safely summarise per lSize using purrr
pred_size2 <- pred_draws_m |>
  group_split(lSize) |>
  map_dfr(function(df) {
    hdi_vals <- hdi(df$.value)
    tibble(
      lSize     = unique(df$lSize),
      median    = median(df$.value),
      lower.HPD = hdi_vals[1],
      upper.HPD = hdi_vals[2]
    )
  })

#View(pred_size2)
#prediction plot
nmsize = 
  ggplot(pred_size2, aes(x = lSize, y = median)) +
  geom_line(size = 0.8) +
  geom_ribbon(aes(ymin = lower.HPD, ymax = upper.HPD), alpha = 0.2, color = NA) +
  scale_y_continuous(
    labels = label_scientific(),
    limits = c(0, 1.0e+06)  # forces the axis to go up to 1e6
  ) +
  theme_bw() +
  theme(text = element_text(family = "serif")) +
  labs(
    x = "lnSize (km²)",
    y = "Estimated maintenance costs (cost/km² p.a.)")
  
 lmsize = 
  ggplot(pred_size2, aes(x = lSize, y = median)) +
    geom_line(size = 0.8) +
    geom_point(data=msubs, aes(x=lSize, y=Cost_km)) +
    geom_ribbon(aes(ymin = lower.HPD, ymax = upper.HPD), alpha = 0.2, color = NA) +
    scale_y_log10(
      labels = label_scientific(),
      limits = c(1e0, 1e07)) +
    theme_bw() +
    theme(text = element_text(family = "serif", size=7), 
        axis.title = element_blank(),
         # These lines remove the grid
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())
  
  png("maitenance size.png", width = 1500, height = 1000, res = 300) 
#final_plot <- 
msize = 
  nmsize +
  inset_element(
    lmsize,
    left = 0.25,
    bottom = 0.45,
    right = 0.98,
    top = 0.95)
dev.off()

```

## Summary plots

### Combining plots

#### Combinign size plots
```{r}
png("size.png", width = 2000, height = 1000, res = 300)
esize + msize
dev.off()

```
#### Size per each protection level - establishment 
```{r}
#prediction of the maintenance costs/km2 per year
pred_draws_e <- emmeans(
  esubs.brm2,
  ~ lSize | Protection_level,
  at = list(
    lSize = seq(min(esubs$lSize), max(esubs$lSize), length.out = 100),
    GDP_pc = mean(esubs$GDP_pc, na.rm = TRUE), 
    Protection_level = unique(esubs$Protection_level))) |>
  gather_emmeans_draws() |>
  mutate(.value = exp(.value))  # back-transform from log

# Now safely summarise per lSize using purrr
pred_size_e <- pred_draws_e |>
  group_split(lSize, Protection_level) |>
  map_dfr(function(df) {
    hdi_vals <- hdi(df$.value)
    tibble(
      lSize     = unique(df$lSize),
      Protection_level = unique(df$Protection_level),
      median    = median(df$.value),
      lower.HPD = hdi_vals[1],
      upper.HPD = hdi_vals[2]
    )
  })
#pred_size2 <- pred_size2 %>%
 # mutate(Protection_level = fct_recode(Protection_level,
  #  "Multi-use areas" = "Partially protected",
   # "Fully Protected Areas" = "Fully protected"
  #))
#View(msubs)


fpe <- subset(pred_size_e, Protection_level == "Fully protected")
mubse <- subset(pred_size_e, Protection_level == "Partially protected")
# Create the plot
nesize_pl <- 
  ggplot() +
  # Fully protected areas
  geom_line(data = fpe, aes(x = lSize, y = median, color = "Fully protected areas"), size = 0.8) +
  geom_ribbon(data = fpe, aes(x = lSize, ymin = lower.HPD, ymax = upper.HPD, fill = "Fully protected areas"), alpha = 0.2) +
  # Partially protected areas
  geom_line(data = mubse, aes(x = lSize, y = median, color = "Multi-use areas"), size = 0.8) +
  geom_ribbon(data = mubse, aes(x = lSize, ymin = lower.HPD, ymax = upper.HPD, fill = "Multi-use areas"), alpha = 0.2) +
  # Customize scales
  scale_color_manual(values = c("Fully protected areas" = "#0072B2", "Multi-use areas" = "#E69F00")) +
  scale_fill_manual(values = c("Fully protected areas" = "#0072B2", "Multi-use areas" = "#E69F00")) +
  # Scientific notation for y-axis
  scale_y_continuous(labels = scales::label_scientific(), limits=c(0, 1.e06)) +
  # Apply theme
  theme_bw() +
  theme(text = element_text(family = "serif"), 
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(), 
        legend.position = "none") +
  # Labels
  labs(
    x = "lnSize (km²)",
    y = "Estimated establishment costs (cost/km²)",
    color = "Protection status",
    fill = "Protection status") +
  coord_cartesian(clip="off") +
  annotate("text", x=-Inf, y=Inf, label="A", hjust=4.5, vjust=0.8, size=5, fontface="bold", family='serif')

lesize_pl = 
  ggplot() +
  geom_line(data = fpe, aes(x = lSize, y = median), color = "#0072B2", size = 0.8) +
  geom_line(data = mubse, aes(x = lSize, y = median), color = "#E69F00", size = 0.8) +
  geom_ribbon(data = fpe, aes(x = lSize, ymin = lower.HPD, ymax = upper.HPD),
              fill = "#0072B2", alpha = 0.2, color = NA) +
  geom_ribbon(data = mubse, aes(x = lSize, ymin = lower.HPD, ymax = upper.HPD),
              fill = "#E69F00", alpha = 0.2, color = NA) +
  geom_point(data = esubs, aes(x = lSize, y = Cost_km, color = Protection_level),
             show.legend = FALSE) +
  scale_color_manual(
    values = c("Fully protected" = "#0072B2", "Partially protected" = "#E69F00"),
    labels = c("Fully protected" = "Fully protected areas",
               "Partially protected" = "Multi-use areas")
  ) +
  scale_y_log10(labels = scales::label_scientific(), limits = c(1e0, 1.0e+07)) +
  theme_bw() +
  theme(text = element_text(family = "serif", size=7),
         axis.title = element_blank(),
         # These lines remove the grid
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()) 
  #labs(
   # x = "lnSize (km²)",
    #y = "Estimated maintenance costs (cost/km² p.a.)",
    #color = "Protection status")
  
tot_e <- nesize_pl +
  inset_element(
    lesize_pl,
     left = 0.25,
    bottom = 0.45,
    right = 0.98,
    top = 0.95)

```



#### Size per each protection level - maintenance

```{r}
#prediction of the maintenance costs/km2 per year
pred_draws_m <- emmeans(
  msubs.brm2,
  ~ lSize | Protection_level,
  at = list(
    lSize = seq(min(msubs$lSize), max(msubs$lSize), length.out = 100),
    GDP_pc = mean(msubs$GDP_pc, na.rm = TRUE), 
    Protection_level = unique(msubs$Protection_level))) |>
  gather_emmeans_draws() |>
  mutate(.value = exp(.value))  # back-transform from log

# Now safely summarise per lSize using purrr
pred_size2 <- pred_draws_m |>
  group_split(lSize, Protection_level) |>
  map_dfr(function(df) {
    hdi_vals <- hdi(df$.value)
    tibble(
      lSize     = unique(df$lSize),
      Protection_level = unique(df$Protection_level),
      median    = median(df$.value),
      lower.HPD = hdi_vals[1],
      upper.HPD = hdi_vals[2]
    )
  })
#pred_size2 <- pred_size2 %>%
 # mutate(Protection_level = fct_recode(Protection_level,
  #  "Multi-use areas" = "Partially protected",
   # "Fully Protected Areas" = "Fully protected"
  #))
#View(msubs)


fp <- subset(pred_size2, Protection_level == "Fully protected")
mubs <- subset(pred_size2, Protection_level == "Partially protected")
nmsize_pl = 
  ggplot() +
  # Fully protected areas
  geom_line(data = fp, aes(x = lSize, y = median, color = "Fully protected areas"), size = 0.8) +
  geom_ribbon(data = fp, aes(x = lSize, ymin = lower.HPD, ymax = upper.HPD, fill = "Fully protected areas"), alpha = 0.2) +
  # Partially protected areas
  geom_line(data = mubs, aes(x = lSize, y = median, color = "Multi-use areas"), size = 0.8) +
  geom_ribbon(data = mubs, aes(x = lSize, ymin = lower.HPD, ymax = upper.HPD, fill = "Multi-use areas"), alpha = 0.2) +
  # Customize scales
  scale_color_manual(values = c("Fully protected areas" = "#0072B2", "Multi-use areas" = "#E69F00")) +
  scale_fill_manual(values = c("Fully protected areas" = "#0072B2", "Multi-use areas" = "#E69F00")) +
  # Scientific notation for y-axis
  scale_y_continuous(labels = scales::label_scientific(), limits=c(0, 1.e06)) +
  # Apply theme
  theme_bw() +
  theme(text = element_text(family = "serif"), 
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()) +
  # Labels
  labs(
    x = "lnSize (km²)",
    y = "Estimated maitenance costs (cost/km² p.a.)",
    color = "Protection status",
    fill = "Protection status") +
  coord_cartesian(clip="off") +
  annotate("text", x=-Inf, y=Inf, label="B", hjust=4.5, vjust=0.8, size=5, fontface="bold", family='serif')
print(nmsize_pl)

lmsize_pl = 
  ggplot() +
  geom_line(data = fp, aes(x = lSize, y = median), color = "#0072B2", size = 0.8) +
  geom_line(data = mubs, aes(x = lSize, y = median), color = "#E69F00", size = 0.8) +
  geom_ribbon(data = fp, aes(x = lSize, ymin = lower.HPD, ymax = upper.HPD),
              fill = "#0072B2", alpha = 0.2, color = NA) +
  geom_ribbon(data = mubs, aes(x = lSize, ymin = lower.HPD, ymax = upper.HPD),
              fill = "#E69F00", alpha = 0.2, color = NA) +
  geom_point(data = msubs, aes(x = lSize, y = Cost_km, color = Protection_level),
             show.legend = FALSE) +
  scale_color_manual(
    values = c("Fully protected" = "#0072B2", "Partially protected" = "#E69F00"),
    labels = c("Fully protected" = "Fully protected areas",
               "Partially protected" = "Multi-use areas")
  ) +
  scale_y_log10(labels = scales::label_scientific(), limits = c(1e0, 1.0e+07)) +
  theme_bw() +
  theme(text = element_text(family = "serif", size=7), 
        axis.title = element_blank(),
         # These lines remove the grid
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())

tot_m <- nmsize_pl +
  inset_element(
    lmsize_pl,
     left = 0.25,
    bottom = 0.45,
    right = 0.98,
    top = 0.95)

```
#### Combinign size plots
```{r}
# Remove legends from individual plots
png("protection level size.png", width = 2500, height = 1300, res = 300)
combined_plot <- tot_e + tot_m
print(combined_plot)
dev.off()
```



### GDP plot

```{r}
#backtrnasformed the response variable to identity (or absolute values) as well as intervals 
#filter the nas
msubs <- msubs |> 
  filter(!is.na(GDP_pc))
pred_draws_GDP <- emmeans(
  msubs.brm2,
  ~ GDP_pc,
  at = list(
   GDP_pc = seq(min(msubs$GDP_pc), max(msubs$GDP_pc), length.out = 100),
    lSize = mean(msubs$lSize, na.rm = TRUE)
  )
) |>
  gather_emmeans_draws() |>
  mutate(.value = exp(.value))  # back-transform from log

# Now safely summarise per lSize using purrr
pred_GDP <- pred_draws_GDP |>
  group_split(GDP_pc) |>
  map_dfr(function(df) {
    hdi_vals <- hdi(df$.value)
    tibble(
      GDP_pc     = unique(df$GDP_pc),
      median    = median(df$.value),
      lower.HPD = hdi_vals[1],
      upper.HPD = hdi_vals[2]
    )
  })

View(pred_GDP)
#producing a predicted ggplot

neGDP_pc = 
  ggplot(pred_GDP, aes(x = GDP_pc, y = median)) +
    geom_line(size = 0.8) +
    geom_ribbon(aes(ymin = lower.HPD, ymax = upper.HPD), alpha = 0.2, color = NA) +
    scale_y_continuous(
      labels = label_scientific()) +
    scale_x_continuous(
      labels = label_scientific()) +
    theme_bw() +
    theme(text = element_text(family = "serif"), 
          panel.grid.minor = element_blank(), 
          panel.grid.major=element_blank()) +
    labs(
      x = "GDP per capita (2023 USD)",
      y = "Estimated maintenance costs (cost/km² p.a.)")
  
leGDP_pc = 
 ggplot(pred_GDP, aes(x = GDP_pc, y = median)) +
  geom_line(size = 0.8) +  # thinner line
  geom_ribbon(aes(ymin = lower.HPD, ymax = upper.HPD), alpha = 0.2, color = NA) +
  geom_point(data=msubs, aes(x=GDP_pc, y=Cost_km)) +
  theme_bw() +
  theme(text = element_text(family = "serif"), 
        axis.title = element_blank(), 
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()) +
  scale_y_log10() +
  scale_x_continuous(
    labels = label_scientific())
  
png("maintenance GDP.png", width = 1500, height = 1000, res = 300) 
#GDP = 
  neGDP_pc +
  inset_element(
    leGDP_pc,
    left = 0.02, 
    bottom = 0.55,
    right = 0.5,
    top = 0.95)
dev.off()
```


