---
title: "Ch3-MPAcosts"
---

# Loading packages needed fro the project

```{r}
library(readr)
library(ggplot2)
library(rnaturalearth) # to make a world map
library(rnaturalearthdata) # data for world map with polygons of the coastline only
library(dplyr)
library(sf)
library(ggspatial) # to add spatial elements to a ggplot map
library(car)
library(cmdstanr)      #for cmdstan
library(brms)          #for fitting models in STAN
library(coda)          #for diagnostics
library(bayesplot)     #for diagnostics
library(DHARMa)        #for residual diagnostics
library(rstan)         #for interfacing with STAN
library(emmeans)       #for marginal means etc
library(broom)         #for tidying outputs
library(tidybayes)     #for more tidying outputs
library(ggeffects)     #for partial plots
library(broom.mixed)   #for summarising models
library(ggeffects)     #for partial effects plots
library(bayestestR)    #for ROPE
library(see)           #for some plots
library(patchwork)     #for multiple plots
library(modelsummary)  #for data and model summaries 
library(ggridges)      #for ridge plots 
library(stringr)
library(tidyr)
```

# Making a map of the MPAs I found data for

## Loading the map data

```{r}
#upload the right data
fig1 <- read_csv("../Data/fig1.csv")
```

## Making global map with my data

```{r}
# Get world map data
world <- ne_countries(scale = "medium", returnclass = "sf")

png("Map1.png", width = 2500, height = 2000, res = 150)
# Create the world map
# Load the coastline data from rnaturalearth
coastline_data <- ne_coastline(scale = "medium", returnclass = "sf")

# Create the plot
ggplot() +  
  # Plot countries in a very light grey
  geom_sf(data = world, fill = "grey95", color = NA) +  
  # Overlay the coastline in black
  geom_sf(data = coastline_data, color = "black", fill = NA) +  
  # Plot your data points
  geom_point(data = fig1, aes(x = Longitude, y = Latitude), color = "#008080", size = 4) +  
  # Set coordinate system
  coord_sf() +
  # Adjust theme
  theme_minimal() +  
  theme(
    axis.text = element_text(size = 24),
    axis.title = element_blank(),  # Removes axis titles
    axis.line.x = element_line(color = "black", size = 0.5),
    axis.line.y = element_line(color = "black", size = 0.5),
    axis.ticks = element_line(color = "black", size = 0.5),
    panel.grid = element_blank()
  )
dev.off()

```


# Statistics

### Loading the data

```{r}
#loading the data
data <- read_csv("../Data/ch3data.csv")
View(data)
#setting up the data
data = data |> mutate(Protection_level=factor(Protection_level))
```

### Data exploration

```{r}
#looking at distribution for costs/km2 divided by gdp class
boxplot(Cost_km~GDP_class, data=data)
#looking at the distribution for cost/km2
hist(data$Cost_km, breaks=60)
#distribution of total costs 
hist(data$'2024_AUD', breaks=60)
#looking at the distribution of costs/km2 divided by cost category
boxplot(Cost_km~Protection_level, data=data)
```

### Making exploratory models

```{r}
#model
# Linear regression model with the specified predictors
model <- lm(Cost_km ~ Protection_level + GDP_pc, data = data)

# View the summary of the model
summary(model)
vif(model)

#plot
plot(model)

# Plot the residuals to check for normality (Gaussian distribution)
#par(mfrow = c(1, 2))  # Set up a 2-panel plot
#plot(model$fitted.values, model$residuals, main = "Residuals vs Fitted", xlab = "Fitted Values", ylab = "Residuals")
#hist(model$residuals, breaks = 30, main = "Histogram of Residuals", xlab = "Residuals", col = "lightblue", border = "black")

#filtering data based on: establishment, maintenance and compliance
establishment = filter(data, Cost_class == "Establishment")
# Linear regression model with the specified predictors
model1 <- lm(Cost_km ~ Protection_level + GDP_pc, data = establishment)
# View the summary of the model
summary(model1)
plot(model1)
View(establishment)

#filtering data based on: establishment, maintenance and compliance
maintenance = filter(data, Cost_class == "Maintenance") # see notes this is not displaying all the maintenance data I have 
#maintenance1 = filter(data, Cost_class %in% c("Administration", "Enforcement", "Management", "Maintenance"))
# Linear regression model with the specified predictors
model2 <- lm(Cost_km ~ Protection_level + GDP_pc, data = maintenance1) # not enough data for this
# View the summary of the model
summary(model2)
plot(model2)
View(maintenance)
```

### Combining and dummy coding levels

```{r}
#using maintenance coded with subs 
msubs <- read_csv("../Data/msubs.csv")
#preparing data
msubs = msubs |> mutate(Protection_level=factor(Protection_level, 
                                                levels=c("Fully protected", "Partially protected")), # this will order them rather than going into alphabetical order 
                        Cost_class=factor(Cost_class, 
                                          levels=c("Maintenance", "Administration", "Enforcement", "Management")),
                        Management=factor(Management, 
                                          levels=c(0,1)), 
                        Administration=factor(Administration, 
                                              levels=c(0,1)), 
                        Enforcement=factor(Enforcement, 
                                           levels=c(0,1)))
View(msubs)
#exploratory model
m1 <- lm(Cost_km ~ Protection_level + GDP_pc + Management + Administration + Enforcement, data=msubs)
summary(m1)
plot(m1)
vif(m1)
```

## Trying a Bayesian regression with Gamma distribution - maintenance subs

```{r}
#sourcing functions from Murray's github repository
source('helperFunctions.R')
#checking distribution 
ggplot(data=msubs, aes(x=Cost_km)) +
  geom_boxplot()
#checking for linearity -> equal variance (no relationship between mean and variance)
ggplot(data=msubs, aes(x=GDP_pc, y=Cost_km)) +
  geom_point() +
  geom_smooth()
#better way for doing this and seeing a straight line in the data 
ggplot(data=msubs, aes(x=GDP_pc, y=Cost_km)) +
  geom_point() +
  geom_smooth(method="lm") 

#looking at distribution 
#looking at the distribution for cost/km2
hist(msubs$Cost_km, breaks=75)

#boxplot
msubs |> ggplot(aes(x=Cost_class, y=Cost_km, fill=Protection_level)) +
  geom_boxplot() +
  geom_point(aes(color=Protection_level), 
             position =position_dodge(width = 0.75))

#plots with no outliers
msubs_filtered <- msubs |> 
  group_by(Cost_class) |> 
  filter(
    Cost_km >= quantile(Cost_km, 0.25) - 1.5 * IQR(Cost_km) &
    Cost_km <= quantile(Cost_km, 0.75) + 1.5 * IQR(Cost_km)
  ) |> 
  ungroup()

# Plot without outliers
ggplot(msubs_filtered, aes(x = Cost_class, y = Cost_km, fill = Protection_level)) +
  geom_boxplot() +
  geom_point(aes(color = Protection_level), position = position_dodge(width = 0.75))

### Fit the model
# mean for each group and mads for each group for our priors
View(msubs)
msubs |> 
  group_by(Protection_level, Administration, Management, Enforcement, GDP_pc) |>  
  summarise(Median=median(log(Cost_km)), MAD=mad(log(Cost_km)))

#setting priors
priors = prior(normal(0, 7), class='Intercept') +
  prior(normal(0,5), class='b') +
  prior(gamma(0.1,0.1), class='shape')

#model formula
form = bf(Cost_km ~ scale(GDP_pc) + Protection_level + Management + Administration + Enforcement, family=Gamma(link='log'))
default_prior(form, data=msubs)
#getting standard priors
get_prior(form, data=msubs)

# running the model with priors only
msubs.brm1 = brm(form, 
               data=msubs, 
               prior=priors,
               sample_prior='only', 
               iter= 5000, 
               warmup = 1000, 
               chains=3, 
               cores = 3, 
               thin=5, 
               refresh=0, 
               seed=1, 
               backend = "cmdstanr")

#making a conditional plot
msubs.brm1 |>
  conditional_effects() |> 
  plot(points=TRUE, ask=FALSE, plot=FALSE) |> 
  wrap_plots() &
  scale_y_log10()

# running the model with both priors and data
msubs.brm2 = msubs.brm1 |> 
  update(sample_prior = 'yes', refresh=0)

#Assess priors and posteriors
msubs.brm2 |> SUYR_prior_and_posterior()

### MCMC sampling diagnostics
#trace plot 
msubs.brm2$fit |> stan_trace()

#border correlarion
msubs.brm2$fit |> stan_ac()

#chain convergence
msubs.brm2$fit |> stan_rhat()

#effective sample size
msubs.brm2$fit |> stan_ess() # there are no issues here

### Model validation

#probability check
msubs.brm2 |> pp_check(type='dens_overlay', ndraws=100)
#not the best fit it could be 

#sim residuals 
msubs.resids  = make_brms_dharma_res(msubs.brm2, integerResponse= TRUE)
testUniformity(msubs.resids)
#simulated residuals are not too bad, acceptable

#check no patterns in the residuals 
plotResiduals(msubs.resids, quantreg = TRUE)
#red lines that there might be some trends occurring, because the line is high and it decreases. 
#without lines we would have not noticed the trends

# results
msubs.brm2 |> 
  as_draws_df() |>  
  dplyr::select(matches("^b_.*")) |> 
  exp() |> 
  summarise_draws(median, 
                  HDInterval::hdi,
                  rhat, 
                  ess_bulk,
                  Pl=~mean(.x<1), 
                  Pg=~mean(.x>1))


```

## Trying a Bayesian regression with Gamma distribution - establishment subs

```{r}
#importing establishment data
esubs <- read_csv("../Data/esubs.csv")

#data preparation
esubs = esubs |> mutate(Protection_level=factor(Protection_level, 
                                                levels=c("Fully protected", "Partially protected")), # this will order them rather than going into alphabetical order 
                        Cost_class=factor(Cost_class, 
                                          levels=c("Establishment", "Research", "Planning", "Community outreach")),
                        Community_outreach=factor(Community_outreach), 
                                          #levels=c(0,1)), 
                        Planning=factor(Planning), 
                                          #levels=c(0,1)), 
                        Research=factor(Research)) 
                                          #levels=c(0,1)))

## Data exploration to see what distribution I can use in the model
#looking at distribution for costs/km2 divided by gdp class
boxplot(Cost_km~Protection_level, data=esubs)
#looking at the distribution for cost/km2
hist(esubs$Cost_km, breaks=75)
#looking at the distribution of costs/km2 divided by cost category
boxplot(Cost_km~Protection_level, data=esubs)

#Visualisiing data
ggplot(data=esubs, aes(x=Cost_km)) +
  geom_boxplot()
#checking for linearity -> equal variance (no relationship between mean and variance)
ggplot(data=esubs, aes(x=GDP_pc, y=Cost_km)) +
  geom_point() +
  geom_smooth()
#better way for doing this and seeing a straight line in the data 
ggplot(data=esubs, aes(x=GDP_pc, y=Cost_km)) +
  geom_point() +
  geom_smooth(method="lm") #decreasing trend

# Calculate the IQR and filter out outliers
esubs_filtered <- esubs |> 
  group_by(Cost_class) |> 
  filter(
    Cost_km >= quantile(Cost_km, 0.25) - 1.5 * IQR(Cost_km) &
    Cost_km <= quantile(Cost_km, 0.75) + 1.5 * IQR(Cost_km)
  ) |> 
  ungroup()

# Plot without outliers
ggplot(esubs_filtered, aes(x = Cost_class, y = Cost_km, fill = Protection_level)) +
  geom_boxplot() +
  geom_point(aes(color = Protection_level), position = position_dodge(width = 0.75))

#boxplot
esubs |> ggplot(aes(x=Cost_class, y=Cost_km, fill=Protection_level)) +
  geom_boxplot() +
  geom_point(aes(color=Protection_level), 
             position =position_dodge(width = 0.75))
boxplot(Cost_km~Protection_level, data=esubs_filtered)
#looking at the distribution for cost/km2
hist(esubs_filtered$Cost_km, breaks=10)

# mean for each group and mads for each group for our priors
esubs |> 
  group_by(Protection_level, GDP_pc) |>  
  summarise(Median=median(log(Cost_km)), MAD=mad(log(Cost_km)))

#model formula
form1 = bf(Cost_km ~ scale(GDP_pc) + Protection_level, family=Gamma(link='log'))
  
#looking at priors needed
get_prior(form1, esubs)

#setting my priors
priors = prior(normal(0, 16), class='Intercept') +
  prior(normal(0,5), class='b') +
  prior(gamma(5,5), class='shape')

# running the model with priors only
esubs.brm1 = brm(form1, 
               data=esubs, 
               prior=priors,
               sample_prior='only', 
               iter= 5000, 
               warmup = 1000, 
               chains=3, 
               cores = 3, 
               thin=5, 
               refresh=0, 
               seed=1, 
               backend = "cmdstanr")

#making a conditional plot
esubs.brm1 |>
  conditional_effects() |> 
  plot(points=TRUE, ask=FALSE, plot=FALSE) |> 
  wrap_plots() &
  scale_y_log10()

# running the model with both priors and data
esubs.brm2 = esubs.brm1 |> 
  update(sample_prior = 'yes', refresh=0)

#Assess priors and posteriors
esubs.brm2 |> SUYR_prior_and_posterior()

### MCMC sampling diagnostics
#trace plot 
esubs.brm2$fit |> stan_trace()

#border correlarion
esubs.brm2$fit |> stan_ac()

#chain convergence
esubs.brm2$fit |> stan_rhat()

#effective sample size
esubs.brm2$fit |> stan_ess() # there are no issues here

### Model validation

#probability check
esubs.brm2 |> pp_check(type='dens_overlay', ndraws=100)
#not the best fit it could be 

#sim residuals 
esubs.resids  = make_brms_dharma_res(esubs.brm2, integerResponse= TRUE)
testUniformity(esubs.resids)
#simulated residuals are not too bad, acceptable

#check no patterns in the residuals 
plotResiduals(esubs.resids, quantreg = TRUE)
#something weird is going on here, not sure what is happening here

#results
# generic summary 
esubs.brm2 |> summary() 

#thorough
esubs.brm2 |> 
  as_draws_df() |>  
  dplyr::select(matches("^b_.*")) |> 
  exp() |> 
  summarise_draws(median, 
                  HDInterval::hdi,
                  rhat, 
                  ess_bulk,
                  Pl=~mean(.x<1), 
                  Pg=~mean(.x>1))

```













