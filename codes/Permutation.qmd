---
title: "permutation"
format: html
---

# Loading packages

```{r}
library(readr)
```

# Establishment costs

## Data preparation

```{r}
#loading the data
esubs <- read_csv("../data/esubs.csv")
#preparing the data
esubs = esubs |> 
  mutate(Protection_level=factor(Protection_level, 
                                                levels=c("Fully protected", "Partially protected")))
# transforming teh data
esubs <- esubs |> 
  mutate(lSize=log(Size), 
         lCost_km=log(Cost_km))
```

## Model fitting

```{r}
#model formula 
form1 = bf(lCost_km ~ scale(lSize) + scale(Years) + Protection_level, family=gaussian)
#setting priors
#setting my priors
priors = prior(normal(11, 1.8), class='Intercept') +
  prior(normal(0,1.8), class='b')

# running the model with priors only
esubs.brm1 = brm(form1, 
               data=esubs, 
               prior=priors,
               sample_prior='only', 
               iter= 5000, 
               warmup = 1000, 
               chains=3, 
               cores = 3, 
               thin=5, 
               refresh=0, 
               seed=123, 
               control = list(adapt_delta=0.99, max_treedepth=29),
               backend = "cmdstanr")
#refresh model wiht data
esubs.brm2 = esubs.brm1 |> 
  update(sample_prior = 'yes', refresh=0)
```

## Permutation

```{r}
# Set the number of permutations
n_permutations <- 1000

# Initialize a matrix to store coefficients from each permutation
perm_coefs <- matrix(NA, nrow = n_permutations, ncol = length(fixef(esubs.brm2)[, "Estimate"]))
colnames(perm_coefs) <- rownames(fixef(esubs.brm2))

# Loop over the number of permutations
for (i in 1:n_permutations) {
  # Shuffle the response variable
  permuted_data <- esubs %>%
    mutate(lCost_km = sample(lCost_km))
  
  # Fit the model to the permuted data
  perm_fit <- brm(
    formula = form1,
    data = permuted_data,
    prior = priors,
    iter = 2000,
    warmup = 500,
    chains = 2,
    cores = 2,
    seed = 123 + i,
    refresh = 0,
    control = list(adapt_delta = 0.99, max_treedepth = 15),
    backend = "cmdstanr"
  )
  
  # Store the estimated coefficients
  perm_coefs[i, ] <- fixef(perm_fit)[, "Estimate"]
}
```

## Results

```{r}
# Original model coefficients
original_coefs <- fixef(esubs.brm2)[, "Estimate"]

# Calculate p-values
p_values <- sapply(1:length(original_coefs), function(j) {
  mean(abs(perm_coefs[, j]) >= abs(original_coefs[j]))
})

# Combine results into a data frame
results <- data.frame(
  Coefficient = names(original_coefs),
  Original_Estimate = original_coefs,
  Permutation_p_value = p_values
)

# View the results
print(results)
```

## Checking permutation

```{r}
# posterior predictive plot 
pp_check(esubs.brm2)  # posterior predictive check
#plotting predicted vs actual values
# Example: assuming your permutation results are in a dataframe called `perm_results`
# with columns: "Coefficient", "Original_Estimate", and "Permutation_p_value"

# Simulated structure:
# - One row per term
# - Original_Estimate is constant per term
# - You also need the full set of permuted estimates per term (a long format dataframe)

# If you have a data frame `perm_dist` like this:
# Columns: Coefficient, Permuted_Estimate

# Convert the permutation matrix to a long dataframe
perm_dist <- as.data.frame(perm_coefs) |>
  mutate(Permutation = 1:n()) |>
  pivot_longer(-Permutation, names_to = "Coefficient", values_to = "Permuted_Estimate")

# Create a dataframe of original (non-permuted) estimates for plotting
orig_estimates_df <- data.frame(
  Coefficient = names(original_coefs),
  Original_Estimate = original_coefs
)

# Plot permutation distributions with original estimate as dashed red line
ggplot(perm_dist, aes(x = Permuted_Estimate)) +
  geom_histogram(bins = 30, fill = "gray80", color = "black") +
  geom_vline(data = orig_estimates_df, aes(xintercept = Original_Estimate),
             color = "red", linetype = "dashed", size = 1.2) +
  facet_wrap(~ Coefficient, scales = "free", ncol = 2) +
  labs(
    title = "Permutation Distribution of Coefficients",
    x = "Permuted Coefficient Estimate",
    y = "Frequency"
  ) +
  theme_minimal()

```

# Maitenance costs

## Data preparation

```{r}
#loading the data
msubs <- read_csv("../Data/msubs.csv")
#Adding a new column for protection level and code it as a as binary --> 1 as fully protected and 0 for partially protected
msubs$Protection_bin<-msubs$Enforcement*NA
msubs$Protection_bin[msubs$Protection_level=="Fully protected"]<-1
msubs$Protection_bin[msubs$Protection_level=="Partially protected"]<-0
```

## Model fitting

```{r}
#standardising the cost_km into smaller values
msubs<- msubs |> 
  mutate(sCost_km=Cost_km/10000) # this is to make the priors smaller and more manageable
#model formula 
#by keeping the intercept at 0 we are forciing the relationship for which maitenance is a combination of management, administration and enforcement, #similarly by scaling the binary coded the protection level we are forcing the model to use the mean of the protection level --> an average MPAs (whatever that is)
form = bf(sCost_km ~ 0 + scale(log(Size)) + scale(GDP_pc) + scale(Protection_bin) + Administration + Enforcement + Management, family=gaussian)
#setting priors
priors =# prior(normal(8, 3), class='Intercept') +
  prior(normal(0,2), class='b') #within brackets add lb=0

# running the model with priors only
msubs.brm1 = brm(form, 
               data=msubs, 
               prior=priors,
               sample_prior='only', 
               iter= 5000, 
               warmup = 1000, 
               chains=3, 
               cores = 3, 
               thin=5, 
               refresh=0, 
               seed=123, 
               control = list(adapt_delta=0.99, max_treedepth=15),
               backend = "cmdstanr")
# running the model with both priors and data
msubs.brm2 = msubs.brm1 |> 
  update(sample_prior = 'yes', refresh=0)

```

## Permutation

```{r}
perm_coefs_m <- matrix(NA, nrow = n_permutations, ncol = length(fixef(msubs.brm2)[, "Estimate"]))
colnames(perm_coefs_m) <- rownames(fixef(msubs.brm2))

# Loop over the number of permutations
for (i in 1:n_permutations) {
  # Shuffle the response variable
  permuted_data_m <- msubs %>%
    mutate(sCost_km = sample(sCost_km))
  
  # Fit the model to the permuted data
  perm_fit_m <- brm(
    formula = form,
    data = permuted_data_m,
    prior = priors,
    iter = 2000,
    warmup = 500,
    chains = 2,
    cores = 2,
    seed = 123 + i,
    refresh = 0,
    control = list(adapt_delta = 0.99, max_treedepth = 15),
    backend = "cmdstanr"
  )
  
  # Store the estimated coefficients
  perm_coefs_m[i, ] <- fixef(perm_fit_m)[, "Estimate"]
}
```

## Results

```{r}
# Original model coefficients
original_coefs_m <- fixef(msubs.brm2)[, "Estimate"]

# Calculate p-values
p_values_m <- sapply(1:length(original_coefs_m), function(j) {
  mean(abs(perm_coefs_m[, j]) >= abs(original_coefs_m[j]))
})

# Combine results into a data frame
results_m <- data.frame(
  Coefficient = names(original_coefs_m),
  Original_Estimate = original_coefs_m,
  Permutation_p_value = p_values_m
)

# View the results
print(results_m)

#summary of bayesian model 
msubs.brm2 |> 
  as_draws_df() |>  
  dplyr::select(matches("^b_.*")) |> 
  summarise_draws(median, 
                  HDInterval::hdi,
                  rhat, 
                  ess_bulk,
                  Pl=~mean(.x<0), 
                  Pg=~mean(.x>0))
```

## Checking the permutation

```{r}
# Convert the permutation matrix to a long dataframe
perm_dist_m <- as.data.frame(perm_coefs_m) |>
  mutate(Permutation = 1:n()) |>
  pivot_longer(-Permutation, names_to = "Coefficient", values_to = "Permuted_Estimate")

# Create a dataframe of original (non-permuted) estimates for plotting
orig_estimates_df_m <- data.frame(
  Coefficient = names(original_coefs_m),
  Original_Estimate = original_coefs_m
)

# Plot permutation distributions with original estimate as dashed red line
ggplot(perm_dist_m, aes(x = Permuted_Estimate)) +
  geom_histogram(bins = 30, fill = "gray80", color = "black") +
  geom_vline(data = orig_estimates_df_m, aes(xintercept = Original_Estimate),
             color = "red", linetype = "dashed", size = 1.2) +
  facet_wrap(~ Coefficient, scales = "free", ncol = 2) +
  labs(
    title = "Permutation Distribution of Coefficients",
    x = "Permuted Coefficient Estimate",
    y = "Frequency"
  ) +
  theme_minimal()
```
