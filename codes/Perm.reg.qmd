---
title: "perm.lm"
format: html
---


```{r}
# Load necessary libraries
library(brms)
library(dplyr)
```

# Establishment costs
```{r}
#import data
esubs <- read.csv("data/esubs.csv")
#data preparation
esubs = esubs |> 
  mutate(Protection_level=factor(Protection_level, 
                                                levels=c("Fully protected", "Partially protected")), 
         ID=factor(ID)) # this will order them rather than going into alphabetical order 
#trnasforming the variables
esubs <- esubs |> 
  mutate(lSize=log(Size), 
         lCost_km=log(Cost_km))

```

```{r}
# Set the number of permutations
n_permutations <- 1000

#form1 = bf(lCost_km ~ scale(lSize) + scale(Years) + scale(GDP_pc) + Protection_level, family=gaussian()) # there is correlation between size and gdp
#correlation is too high to be able to include gdp or size in the model, however we can say that size explains more of the variance so we can use size size as a proxy for the gdp and only include the size in the model
form1 = bf(lCost_km ~ scale(lSize) + scale(Years) + Protection_level, family=gaussian)
#View(esubs)
# mean for each group and mads for each group for our priors
esubs |> group_by(Protection_level) |>
  summarise(Median=median(lCost_km), MAD=mad(lCost_km))

#setting my priors
priors = prior(normal(11, 1.8), class='Intercept') +
  prior(normal(0,1.8), class='b')

# running the model with priors only
esubs.brm1 = brm(form1, 
               data=esubs, 
               prior=priors,
               sample_prior='only', 
               iter= 5000, 
               warmup = 1000, 
               chains=3, 
               cores = 3, 
               thin=5, 
               refresh=0, 
               seed=123, 
               control = list(adapt_delta=0.99, max_treedepth=29),
               backend = "cmdstanr")

# running the model with both priors and data
esubs.brm2 = esubs.brm1 |> 
  update(sample_prior = 'yes', refresh=100)

# Initialize a matrix to store coefficients from each permutation
perm_coefs <- matrix(NA, nrow = n_permutations, ncol = length(fixef(esubs.brm2)[, "Estimate"]))
colnames(perm_coefs) <- rownames(fixef(esubs.brm2))

# Loop over the number of permutations
for (i in 1:n_permutations) {
  # Shuffle the response variable
  permuted_data <- esubs %>%
    mutate(lCost_km = sample(lCost_km))
  
  # Fit the model to the permuted data
  perm_fit <- brm(
    formula = form1,
    data = permuted_data,
    prior = priors,
    iter = 2000,
    warmup = 500,
    chains = 2,
    cores = 2,
    seed = 123 + i,
    refresh = 0,
    control = list(adapt_delta = 0.99, max_treedepth = 15),
    backend = "cmdstanr"
  )
  
  # Store the estimated coefficients
  perm_coefs[i, ] <- fixef(perm_fit)[, "Estimate"]
}

```

```{r}
# Original model coefficients
original_coefs <- fixef(esubs.brm2)[, "Estimate"]

# Calculate p-values
p_values <- sapply(1:length(original_coefs), function(j) {
  mean(abs(perm_coefs[, j]) >= abs(original_coefs[j]))
})

# Combine results into a data frame
results <- data.frame(
  Coefficient = names(original_coefs),
  Original_Estimate = original_coefs,
  Permutation_p_value = p_values
)

# View the results
print(results)

# calculate the change in cost
change <- (exp(results$Original_Estimate) - 1) * 100 

```

```{r}
# Example: assuming your permutation results are in a dataframe called `perm_results`
# with columns: "Coefficient", "Original_Estimate", and "Permutation_p_value"

# Simulated structure:
# - One row per term
# - Original_Estimate is constant per term
# - You also need the full set of permuted estimates per term (a long format dataframe)

# If you have a data frame `perm_dist` like this:
# Columns: Coefficient, Permuted_Estimate

# Convert the permutation matrix to a long dataframe
perm_dist <- as.data.frame(perm_coefs) |>
  mutate(Permutation = 1:n()) |>
  pivot_longer(-Permutation, names_to = "Coefficient", values_to = "Permuted_Estimate")

# Create a dataframe of original (non-permuted) estimates for plotting
orig_estimates_df <- data.frame(
  Coefficient = names(original_coefs),
  Original_Estimate = original_coefs
)

# Plot permutation distributions with original estimate as dashed red line
ggplot(perm_dist, aes(x = Permuted_Estimate)) +
  geom_histogram(bins = 30, fill = "gray80", color = "black") +
  geom_vline(data = orig_estimates_df, aes(xintercept = Original_Estimate),
             color = "red", linetype = "dashed", size = 1.2) +
  facet_wrap(~ Coefficient, scales = "free", ncol = 2) +
  labs(
    title = "Permutation Distribution of Coefficients",
    x = "Permuted Coefficient Estimate",
    y = "Frequency"
  ) +
  theme_minimal()


```

# Maitenance costs
```{r}
#using maintenance coded with subs 
msubs <- read_csv("../Data/msubs.csv")
#View(msubs)
#preparing data
#msubs = msubs |> mutate(Protection_level=factor(Protection_level, 
                                                #levels=c("Fully protected", "Partially protected")))#, # this will order them rather than going into a
summary(msubs)

#Adding a new column for protection level and code it as a as binary --> 1 as fully protected and 0 for partially protected
msubs$Protection_bin<-msubs$Enforcement*NA
msubs$Protection_bin[msubs$Protection_level=="Fully protected"]<-1
msubs$Protection_bin[msubs$Protection_level=="Partially protected"]<-0
```
```{r}
#standardising the cost_km into smaller values
msubs<- msubs |> 
  mutate(sCost_km=Cost_km/10000) # this is to make the priors smaller and more manageable
#model formula 
#by keeping the intercept at 0 we are forciing the relationship for which maitenance is a combination of management, administration and enforcement, #similarly by scaling the binary coded the protection level we are forcing the model to use the mean of the protection level --> an average MPAs (whatever that is)
form = bf(Cost_km ~ 0 + scale(log(Size)) + scale(GDP_pc) + scale(Protection_bin) + Administration + Enforcement + Management, family=gaussian)
# mean for each group and mads for each group for our priors
msubs |> 
  summarise(Median=median(Cost_km), MAD=mad(Cost_km))

#setting priors
priors =# prior(normal(8, 3), class='Intercept') +
  prior(normal(0,4500), class='b') #within brackets add lb=0

# running the model with priors only
msubs.brm1 = brm(form, 
               data=msubs, 
               prior=priors,
               sample_prior='only', 
               iter= 5000, 
               warmup = 1000, 
               chains=3, 
               cores = 3, 
               thin=5, 
               refresh=0, 
               seed=123, 
               control = list(adapt_delta=0.99, max_treedepth=15),
               backend = "cmdstanr")


# running the model with both priors and data
msubs.brm2 = msubs.brm1 |> 
  update(sample_prior = 'yes', refresh=0)

perm_coefs_m <- matrix(NA, nrow = n_permutations, ncol = length(fixef(msubs.brm2)[, "Estimate"]))
colnames(perm_coefs_m) <- rownames(fixef(msubs.brm2))

# Loop over the number of permutations
for (i in 1:n_permutations) {
  # Shuffle the response variable
  permuted_data_m <- msubs %>%
    mutate(Cost_km = sample(Cost_km))
  
  # Fit the model to the permuted data
  perm_fit_m <- brm(
    formula = form,
    data = permuted_data_m,
    prior = priors,
    iter = 2000,
    warmup = 500,
    chains = 2,
    cores = 2,
    seed = 123 + i,
    refresh = 0,
    control = list(adapt_delta = 0.99, max_treedepth = 15),
    backend = "cmdstanr"
  )
  
  # Store the estimated coefficients
  perm_coefs_m[i, ] <- fixef(perm_fit_m)[, "Estimate"]
}

```

```{r}
# Original model coefficients
original_coefs_m <- fixef(msubs.brm2)[, "Estimate"]

# Calculate p-values
p_values_m <- sapply(1:length(original_coefs_m), function(j) {
  mean(abs(perm_coefs_m[, j]) >= abs(original_coefs_m[j]))
})

# Combine results into a data frame
results_m <- data.frame(
  Coefficient = names(original_coefs_m),
  Original_Estimate = original_coefs_m,
  Permutation_p_value = p_values_m
)

# View the results
print(results_m)

# calculate the change in cost
change <- (results_m$Original_Estimate - 1) * 100 
print(change)
#summary of bayesian model 
msubs.brm2 |> 
  as_draws_df() |>  
  dplyr::select(matches("^b_.*")) |> 
  summarise_draws(median, 
                  HDInterval::hdi,
                  rhat, 
                  ess_bulk,
                  Pl=~mean(.x<0), 
                  Pg=~mean(.x>0))
print(results_m)
```
```{r}
# Convert the permutation matrix to a long dataframe
perm_dist_m <- as.data.frame(perm_coefs_m) |>
  mutate(Permutation = 1:n()) |>
  pivot_longer(-Permutation, names_to = "Coefficient", values_to = "Permuted_Estimate")

# Create a dataframe of original (non-permuted) estimates for plotting
orig_estimates_df_m <- data.frame(
  Coefficient = names(original_coefs_m),
  Original_Estimate = original_coefs_m
)

# Plot permutation distributions with original estimate as dashed red line
ggplot(perm_dist_m, aes(x = Permuted_Estimate)) +
  geom_histogram(bins = 30, fill = "gray80", color = "black") +
  geom_vline(data = orig_estimates_df_m, aes(xintercept = Original_Estimate),
             color = "red", linetype = "dashed", size = 1.2) +
  facet_wrap(~ Coefficient, scales = "free", ncol = 2) +
  labs(
    title = "Permutation Distribution of Coefficients",
    x = "Permuted Coefficient Estimate",
    y = "Frequency"
  ) +
  theme_minimal()
```



