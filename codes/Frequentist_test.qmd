---
title: "frequentist"
format: html
---

# statistics frequentist

## packages

```{r}
library(readr)
```

```{r}
#importing data 
esubs <- read_csv("../Data/esubs.csv")
#fixing levels of the data
esubs = esubs |> 
  mutate(Protection_level=factor(Protection_level, 
                                                levels=c("Fully protected", "Partially protected")), 
         ID=factor(ID)) # this will order them rather than going into alphabetical order 
head(esubs)
#log response variable
esubs <- esubs |>  mutate(lCost_km = log(Cost_km), 
                          lSize = log(Size))
hist(esubs$lCost_km)
#making a frequentist model 
m1 = lm(lCost_km ~ scale(lSize) + scale(Years) + Protection_level, esubs, family=gaussian)
summary(m1)
plot(m1)
#back transform the estimates
exp(m1$coefficients)
summary(esubs)
hist(m1$residuals)

```

```{r}
#importing data 
msubs <- read_csv("../Data/msubs.csv")
View(msubs)
#fixing levels of the data
msubs = msubs |> mutate( #(Protection_level=factor(Protection_level, 
                                                #levels=c("Fully protected", "Partially protected")), # this will order them rather than going into alphabetical order 
                        Cost_class=factor(Cost_class, 
                                          levels=c("Maintenance", "Administration", "Enforcement", "Management")))
                        #,
                        #Management=factor(Management, 
                                          #levels=c(1,0)), 
                        #Administration=factor(Administration, 
                                              #levels=c(1,0)), 
                        #Enforcement=factor(Enforcement, 
                                           #levels=c(1,0)), 
                        #ID=factor(ID))
head(msubs)
aggregate(as.numeric(as.character(Cost_km)) ~ Cost_class, data = msubs, FUN = mean)
msubs <- msubs |> 
  mutate(lSize = log(Size))
aggregate(as.numeric(as.character(lSize)) ~ Cost_class, data = msubs, FUN = mean)
aggregate(as.numeric(as.character(GDP_pc)) ~ Cost_class, data = msubs, FUN = mean)

#making a frequentist model 
m2 = lm(lCost_km ~ 0+scale(log(Size)) + Administration + Enforcement + Management, msubs, family=gaussian)
summary(m2)

plot(log(msubs$Size), msubs$Cost_km)
#back transform the estimates
exp(m2$coefficients)
```

# Bayesian with normal distribution

```{r}
#starting setting up the model
esubs <- esubs |> mutate(Cost_km = log(Cost_km))
#model formula
form1 = bf(Cost_km ~ scale(Size) + scale(Years) + scale(GDP_pc) + Protection_level, family=gaussian)
#View(esubs)#View(esubs)gaussian()
# mean for each group and mads for each group for our priors
esubs |> 
  summarise(Median=median(log(Cost_km)), MAD=mad(log(Cost_km)))
  
#looking at priors needed
get_prior(form1, esubs)

#setting my priors
priors = prior(normal(0.08, 0.8), class='Intercept') +
  prior(normal(0,0.8), class='b')

# running the model with priors only
esubs.brm1 = brm(form1, 
               data=esubs, 
               prior=priors,
               sample_prior='only', 
               iter= 5000, 
               warmup = 1000, 
               chains=3, 
               cores = 3, 
               thin=5, 
               refresh=0, 
               seed=1, 
               backend = "cmdstanr")

#making a conditional plot
esubs.brm1 |>
  conditional_effects() |> 
  plot(points=TRUE)

#making a conditional plot on a better scale 
esubs.brm1 |>
  conditional_effects() |> 
  plot(points=TRUE) |> 
  wrap_plots() &
  scale_y_log10() # I had to increase the priors because they were not wide enough

# running the model with both priors and data
esubs.brm2 = esubs.brm1 |> 
  update(sample_prior = 'yes', refresh=0)

#Assess priors and posteriors
esubs.brm2 |> SUYR_prior_and_posterior()

#Produce the same conditional plot but with the posteriors
esubs.brm2 |>
  conditional_effects() |> 
  plot(points=TRUE) |> 
  wrap_plots() &
  scale_y_log10()
#priors are not influential but there is very little data
```

```{r}
#trace plot 
esubs.brm2$fit |> stan_trace()

#border correlarion
esubs.brm2$fit |> stan_ac()

#chain convergence
esubs.brm2$fit |> stan_rhat()
#all values less than 1.01

#effective sample size
esubs.brm2$fit |> stan_ess() # there are no issues here
#values higher than 0.5 and as close to 1 as possible, otherwise it means that the sampler drifted away

#check the densities
esubs.brm2$fit |> stan_dens(separate_chains=TRUE)
#this plot is good if we have high hats 
```

```{r}
esubs.brm2 |> pp_check(type='dens_overlay', ndraws=100)
esubs.resids  = make_brms_dharma_res(esubs.brm2, integerResponse= TRUE)
testUniformity(esubs.resids)
plotResiduals(esubs.resids, quantreg = TRUE)
```

## Results

```{r}
# generic summary 
esubs.brm2 |> summary() 
esubs.brm2 |> 
  as_draws_df() |>  
  dplyr::select(matches("^b_.*")) |> 
  summarise_draws(median, 
                  HDInterval::hdi,
                  rhat, 
                  ess_bulk,
                  Pl=~mean(.x<0), 
                  Pg=~mean(.x>0))
pred_size <- emmeans(
  esubs.brm2,
  ~ Size | Protection_level,
  at = list(Size = seq(min(esubs$Size), max(esubs$Size), length.out = 100),
            Years = mean(esubs$Years, na.rm = TRUE)),
  type = "response"
) |> as.data.frame()
View(pred_size)

ggplot(pred_size, aes(x = Size, y = emmean, color = Protection_level, fill = Protection_level)) +
  geom_line(size = 0.8) +  # thinner line
  geom_ribbon(aes(ymin = lower.HPD, ymax = upper.HPD), alpha = 0.2, color = NA) +
  theme_bw() +
  theme(text = element_text(family = "serif")) +
  scale_fill_manual(
    name = "Protection status",
    values = c("Fully protected" = "#0072B2", "Partially protected" = "#D55E00"),
    labels = c("Fully protected" = "Fully protected", "Partially protected" = "Multi-use areas")
  ) +
  scale_color_manual(
    name = "Protection status",
    values = c("Fully protected" = "#0072B2", "Partially protected" = "#D55E00"),
    labels = c("Fully protected" = "Fully protected", "Partially protected" = "Multi-use areas")
  ) +
  labs(
    x = "Size (km²)",
    y = "Establishment cost/km²"
  )
```

# Maitenance costs - Bayesian normal distribution

```{r}
#starting setting up the model
msubs <- msubs |> mutate(Cost_km = log(Cost_km))
#model formula
form = bf(Cost_km ~ scale(Size) + scale(GDP_pc) + Protection_level, family=gaussian)
# mean for each group and mads for each group for our priors
msubs |> 
  summarise(Median=median(log(Cost_km)), MAD=mad(log(Cost_km)))

#getting standard priors
get_prior(form, data=msubs)

#setting priors
priors = prior(normal(0.7, 0.2), class='Intercept') + 
  prior(normal(0,0.2), class='b')

# running the model with priors only
msubs.brm1 = brm(form, 
               data=msubs, 
               prior=priors,
               sample_prior='only', 
               iter= 5000, 
               warmup = 1000, 
               chains=3, 
               cores = 3, 
               thin=5, 
               refresh=0, 
               seed=1, 
               backend = "cmdstanr")

#making a conditional plot
msubs.brm1 |>
  conditional_effects() |> 
  plot(points=TRUE, ask=FALSE, plot=FALSE) |> 
  wrap_plots() &
  scale_y_log10()

# running the model with both priors and data
msubs.brm2 = msubs.brm1 |> 
  update(sample_prior = 'yes', refresh=0)

#Assess priors and posteriors
msubs.brm2 |> SUYR_prior_and_posterior()

#Produce the same conditional plot but with the posteriors
msubs.brm2 |>
  conditional_effects() |> 
  plot(points=TRUE) |> 
  wrap_plots() &
  scale_y_log10()
#priors are not influential but there is very little data
```

## MCMC validation

```{r}
#trace plot 
msubs.brm2$fit |> stan_trace()

#border correlarion
msubs.brm2$fit |> stan_ac()

#chain convergence
msubs.brm2$fit |> stan_rhat()

#effective sample size
msubs.brm2$fit |> stan_ess() # there are no issues here

#check the densities
msubs.brm2$fit |> stan_dens(separate_chains=TRUE)
#this plot is good if we have high hats 
```

## Model validation

```{r}
#probability check
msubs.brm2 |> pp_check(type='dens_overlay', ndraws=100) #+
    #xlim(0, 5.0e+05)
#not the best fit it could be 

#sim residuals 
msubs.resids  = make_brms_dharma_res(msubs.brm2, integerResponse= TRUE)
testUniformity(msubs.resids)
#simulated residuals are not too bad, acceptable

#check no patterns in the residuals 
plotResiduals(msubs.resids, quantreg = TRUE)
#red lines that there might be some trends occurring, because the line is high and it decreases. 
#without lines we would have not noticed the trends
```

```{r}

```
