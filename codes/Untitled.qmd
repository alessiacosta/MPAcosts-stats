---
title: "gpd stats"
format: html
---
# Loading packages needed for the project
```{r}
library(readr)
library(ggplot2)
library(rnaturalearth) # to make a world map
library(rnaturalearthdata) # data for world map with polygons of the coastline only
library(dplyr)
library(sf)
library(ggspatial) # to add spatial elements to a ggplot map
library(car)
library(cmdstanr)      #for cmdstan
library(brms)          #for fitting models in STAN
library(coda)          #for diagnostics
library(bayesplot)     #for diagnostics
library(DHARMa)        #for residual diagnostics
library(rstan)         #for interfacing with STAN
library(emmeans)       #for marginal means etc
library(broom)         #for tidying outputs
library(tidybayes)     #for more tidying outputs
library(ggeffects)     #for partial plots
library(broom.mixed)   #for summarising models
library(ggeffects)     #for partial effects plots
library(bayestestR)    #for ROPE
library(see)           #for some plots
library(patchwork)     #for multiple plots
library(modelsummary)  #for data and model summaries 
library(ggridges)      #for ridge plots 
library(stringr)
library(tidyr)
library(geoR)
library(scales)
#sourcing functions from Murray's github repository
source('helperFunctions.R')
```


## Bayesian regression with Gamma distribution - GDP per capita for establishment costs

#### Data preparation
```{r}
#importing establishment data
esubs <- read_csv("../Data/esubs.csv")
#View(esubs)
#removing the last two rows from the dataset cause for some reason it pops up as NAs
#esubs <- head(esubs, -2)
#View(esubs)

#data preparation
esubs = esubs |> 
  mutate(Protection_level=factor(Protection_level, 
                                                levels=c("Fully protected", "Partially protected")), 
         ID=factor(ID)) # this will order them rather than going into alphabetical order 
#View(esubs)
```


#### Exploratory analysis
```{r}
#checking for linearity 
esubs |> ggplot(aes(y=Cost_km, x=GDP_pc)) +
  geom_point() +
  geom_line(aes(group=ID))
# need this to be more clear to see what whether there are patterns

#making a facet 
esubs |> ggplot(aes(y=Cost_km, x=Years)) +
  geom_point() +
  geom_smooth(method="lm") +
  facet_wrap(~ID)
```


#### Fit the model
```{r}
#model formula
form = bf(Cost_km ~ scale(GDP_pc), family=Gamma(link='log'))
# mean for each group and mads for each group for our priors
esubs |> 
  summarise(Median=median(log(Cost_km)), MAD=mad(log(Cost_km)))

#getting standard priors
get_prior(form, data=esubs)

#setting priors
priors = prior(normal(12, 4), class='Intercept') +
  prior(normal(0,4), class='b') +
  prior(gamma(0.1,0.1), class='shape')

# running the model with priors only
esubs.brm11 = brm(form, 
               data=esubs, 
               prior=priors,
               sample_prior='only', 
               iter= 5000, 
               warmup = 1000, 
               chains=3, 
               cores = 3, 
               thin=5, 
               refresh=0, 
               seed=1, 
               backend = "cmdstanr")

#making a conditional plot
esubs.brm11 |>
  conditional_effects() |> 
  plot(points=TRUE, ask=FALSE, plot=FALSE) |> 
  wrap_plots() &
  scale_y_log10()

# running the model with both priors and data
esubs.brm22 = esubs.brm11 |> 
  update(sample_prior = 'yes', refresh=0)

#Assess priors and posteriors
esubs.brm22 |> SUYR_prior_and_posterior()

#Produce the same conditional plot but with the posteriors
esubs.brm22 |>
  conditional_effects() |> 
  plot(points=TRUE) |> 
  wrap_plots() &
  scale_y_log10()
#priors are not influential but there is very little data
```


#### MCMC sampling
```{r}
#trace plot 
esubs.brm22$fit |> stan_trace()

#border correlarion
esubs.brm22$fit |> stan_ac()

#chain convergence
esubs.brm22$fit |> stan_rhat()

#effective sample size
esubs.brm22$fit |> stan_ess() # there are no issues here

#check the densities
esubs.brm22$fit |> stan_dens(separate_chains=TRUE)
#this plot is good if we have high hats 
```


#### Model validation
```{r}
#probability check
esubs.brm22 |> pp_check(type='dens_overlay', ndraws=100) + 
  xlim(0, 5.0e+06)
#not the best fit it could be 

#sim residuals 
esubs.resids1  = make_brms_dharma_res(esubs.brm22, integerResponse= TRUE)
testUniformity(esubs.resids1)
#simulated residuals are not too bad, acceptable - deviation n.s. means no significant deviation 

#check no patterns in the residuals 
plotResiduals(esubs.resids1, quantreg = TRUE)
#no issues here, looks half decent
#the diagnostics look fine but we know we need to check other things based on the pp check
```



#### Results
```{r}
# generic summary 
esubs.brm22 |> summary() 

#thorough results
esubs.brm22 |> 
  as_draws_df() |>  
  dplyr::select(matches("^b_.*")) |> 
  exp() |> 
  summarise_draws(median, 
                  HDInterval::hdi,
                  rhat, 
                  ess_bulk,
                  Pl=~mean(.x<1), 
                  Pg=~mean(.x>1))

#There is strong evidence 99% - Pl - ((1-0.2)*100) that we have a 80% decrease in cost_km for one unit increase in GDP per capita

#the amount of variability explained by the model -quasi R sqaured
esubs.brm22 |> bayes_R2(summary=FALSE) |> median_hdci()
#we are explaining 10% of the variance with this model -  which should be a pretty good fit for the model
```



#### Plot results - predictions
```{r}
# Filter out NAs in the relevant columns
esubs_GDP <- esubs |> 
  filter(!is.na(GDP_pc))
# Generate a sequence of GDP values to predict over
gdp_seq <- seq(min(esubs_GDP$GDP_pc), max(esubs_GDP$GDP_pc), length.out = 100)
# Use emmeans to get the predictions on the response scale
pred_gdp <- emmeans(
  esubs.brm22,
  ~ GDP_pc,
  at = list(GDP_pc = gdp_seq),
  type = "response"
) |> 
  as.data.frame()

#plot
png("h5.png", width = 1400, height = 800, res = 300)
ggplot(pred_gdp, aes(x = GDP_pc, y = response)) +
  geom_line(color = "#0072B2", size = 1) +
  geom_ribbon(aes(ymin = lower.HPD, ymax = upper.HPD), fill = "#0072B2", alpha = 0.2) +
  theme_bw() +
  theme(text = element_text(family = "serif")) +
  labs(
    x = "GDP per capita (USD)",
    y = "Establsihment cost/km²"
  ) +
  scale_y_log10()
dev.off()
```






## Bayesian regression with Gamma distribution - GDP per capita for maitenance costs

#### Data preparation
```{r}
#using maintenance coded with subs 
msubs <- read_csv("../Data/msubs.csv")
#View(msubs)
#preparing data
msubs = msubs |> mutate(Protection_level=factor(Protection_level, 
                                                levels=c("Fully protected", "Partially protected")), # this will order them rather than going into alphabetical order 
                        Cost_class=factor(Cost_class, 
                                          levels=c("Maintenance", "Administration", "Enforcement", "Management")),
                        Management=factor(Management, 
                                          levels=c(1,0)), 
                        Administration=factor(Administration, 
                                              levels=c(1,0)), 
                        Enforcement=factor(Enforcement, 
                                           levels=c(1,0)), 
                        ID=factor(ID))
```



#### Exploratory analysis
```{r}
#checking for linearity 
msubs |> ggplot(aes(y=Cost_km, x=GDP_pc)) +
  geom_point() +
  geom_line(aes(group=ID))
# need this to be more clear to see what whether there are patterns

#making a facet 
msubs |> ggplot(aes(y=Cost_km, x=GDP_pc)) +
  geom_point() +
  geom_smooth(method="lm") +
  facet_wrap(~ID)
```

#### Fit the model
```{r}
#model formula
form = bf(Cost_km ~ scale(GDP_pc), family=Gamma(link='log'))
# mean for each group and mads for each group for our priors
msubs |> 
  summarise(Median=median(log(Cost_km)), MAD=mad(log(Cost_km)))

#getting standard priors
get_prior(form, data=msubs)

#setting priors
priors = prior(normal(8, 2.5), class='Intercept') +
  prior(normal(0,2.5), class='b') +
  prior(gamma(0.1,0.1), class='shape')

# running the model with priors only
msubs.brm11 = brm(form, 
               data=msubs, 
               prior=priors,
               sample_prior='only', 
               iter= 5000, 
               warmup = 1000, 
               chains=3, 
               cores = 3, 
               thin=5, 
               refresh=0, 
               seed=1, 
               backend = "cmdstanr")

#making a conditional plot
msubs.brm11 |>
  conditional_effects() |> 
  plot(points=TRUE, ask=FALSE, plot=FALSE) |> 
  wrap_plots() &
  scale_y_log10()

# running the model with both priors and data
msubs.brm22 = msubs.brm11 |> 
  update(sample_prior = 'yes', refresh=0)

#Assess priors and posteriors
msubs.brm22 |> SUYR_prior_and_posterior()

#Produce the same conditional plot but with the posteriors
msubs.brm22 |>
  conditional_effects() |> 
  plot(points=TRUE) |> 
  wrap_plots() &
  scale_y_log10()
#priors are not influential but there is very little data
```

#### MCMC sampling
```{r}
#trace plot 
msubs.brm22$fit |> stan_trace()

#border correlarion
msubs.brm22$fit |> stan_ac()

#chain convergence
msubs.brm22$fit |> stan_rhat()

#effective sample size
msubs.brm22$fit |> stan_ess() # there are no issues here

#check the densities
msubs.brm22$fit |> stan_dens(separate_chains=TRUE)
#this plot is good if we have high hats 
```

#### Model validation
```{r}
#probability check
msubs.brm22 |> pp_check(type='dens_overlay', ndraws=100) + 
  xlim(0, 5.0e+06)
#not the best fit it could be 

#sim residuals 
msubs.resids1  = make_brms_dharma_res(msubs.brm22, integerResponse= TRUE)
testUniformity(msubs.resids1)
#simulated residuals are not too bad, acceptable - deviation n.s. means no significant deviation 

#check no patterns in the residuals 
plotResiduals(msubs.resids1, quantreg = TRUE)
#no issues here, looks half decent
#the diagnostics look fine but we know we need to check other things based on the pp check
```

#### Results
```{r}
# generic summary 
msubs.brm22 |> summary() 

#thorough results
msubs.brm22 |> 
  as_draws_df() |>  
  dplyr::select(matches("^b_.*")) |> 
  exp() |> 
  summarise_draws(median, 
                  HDInterval::hdi,
                  rhat, 
                  ess_bulk,
                  Pl=~mean(.x<1), 
                  Pg=~mean(.x>1))

#There is strong evidence 99% - Pl - ((1-0.2)*100) that we have a 80% decrease in cost_km for one unit increase in GDP per capita

#the amount of variability explained by the model -quasi R sqaured
msubs.brm22 |> bayes_R2(summary=FALSE) |> median_hdci()
#we are explaining 10% of the variance with this model -  which should be a pretty good fit for the model
```
#### Plot results - predictions
```{r}
# Filter out NAs in the relevant columns
msubs_GDP <- msubs |> 
  filter(!is.na(GDP_pc))
# Generate a sequence of GDP values to predict over
gdp_seq1 <- seq(min(msubs_GDP$GDP_pc), max(msubs_GDP$GDP_pc), length.out = 100)
# Use emmeans to get the predictions on the response scale
pred_gdp1 <- emmeans(
  msubs.brm22,
  ~ GDP_pc,
  at = list(GDP_pc = gdp_seq1),
  type = "response"
) |> 
  as.data.frame()

#plot
png("h6.png", width = 1400, height = 800, res = 300)
ggplot(pred_gdp1, aes(x = GDP_pc, y = response)) +
  geom_line(color = "#0072B2", size = 1) +
  geom_ribbon(aes(ymin = lower.HPD, ymax = upper.HPD), fill = "#0072B2", alpha = 0.2) +
  theme_bw() +
  theme(text = element_text(family = "serif")) +
  labs(
    x = "GDP per capita (USD)",
    y = "Maintenance cost/km²"
  ) +
  scale_y_log10()
dev.off()
```









### Combining plots 
#### Prediction of costs/km2 with change in GPD per capita
```{r}
# Average response at each Size value for maintenance
pred_maint1 <- pred_gdp1 |> 
  group_by(GDP_pc) |> 
  summarise(
    response = mean(response),
    lower.HPD = mean(lower.HPD),
    upper.HPD = mean(upper.HPD)
  )
# Establishment cost prediction
pred_estab1 <- pred_gdp |> 
  group_by(GDP_pc) |> 
  summarise(
    response = mean(response),
    lower.HPD = mean(lower.HPD),
    upper.HPD = mean(upper.HPD)
  )
#adding 'type' so I can assign different colors to them 
pred_maint1$type <- "Maintenance"
pred_estab1$type <- "Establishment"
#combine the two into one dataframe
pred_combined1 <- bind_rows(pred_maint1, pred_estab1)

# Plot
png("h0.png", width = 1400, height = 800, res = 300)
ggplot(pred_combined1, aes(x = GDP_pc, y = response, color = type, fill = type)) +
  geom_line(size = 0.8) +
  geom_ribbon(aes(ymin = lower.HPD, ymax = upper.HPD), alpha = 0.2, color = NA) +
  scale_x_continuous(labels = label_scientific()) +
  scale_y_log10(labels = label_scientific()) +
  theme_bw() +
  theme(text = element_text(family = "serif")) +
  labs(
    x = "GDP per capita (2023 USD)",
    y = "Cost/km²",
    color = "Cost type",
    fill = "Cost type"
  ) +
  scale_color_manual(values = c("Maintenance" = "#0072B2", "Establishment" = "#D55E00")) +
  scale_fill_manual(values = c("Maintenance" = "#0072B2", "Establishment" = "#D55E00"))
dev.off()
```



## Bayesian regression with Gamma distribution - GDP per capita for maitenance costs with interaction 

#### Data preparation 
Not needed because the dataset is the same as first model

#### Exploratory analysis
```{r}
#checking for linearity 
msubs |> ggplot(aes(y=Cost_km, x=GDP_pc)) +
  geom_point() +
  geom_line(aes(group=ID))
# need this to be more clear to see what whether there are patterns

#making a facet 
msubs |> ggplot(aes(y=Cost_km, x=GDP_pc)) +
  geom_point() +
  geom_smooth(method="lm") +
  facet_wrap(~ID)
```

#### Fit the model
```{r}
#model formula
form = bf(Cost_km ~ scale(GDP_pc)*Protection_level, family=Gamma(link='log'))
# mean for each group and mads for each group for our priors
msubs |> 
  summarise(Median=median(log(Cost_km)), MAD=mad(log(Cost_km)))

#getting standard priors
get_prior(form, data=msubs)

#setting priors
priors = prior(normal(8, 2.5), class='Intercept') +
  prior(normal(0,2.5), class='b') +
  prior(gamma(0.1,0.1), class='shape')

# running the model with priors only
msubs.brm111 = brm(form, 
               data=msubs, 
               prior=priors,
               sample_prior='only', 
               iter= 5000, 
               warmup = 1000, 
               chains=3, 
               cores = 3, 
               thin=5, 
               refresh=0, 
               seed=1, 
               backend = "cmdstanr")

#making a conditional plot
msubs.brm111 |>
  conditional_effects() |> 
  plot(points=TRUE, ask=FALSE, plot=FALSE) |> 
  wrap_plots() &
  scale_y_log10()

# running the model with both priors and data
msubs.brm222 = msubs.brm111 |> 
  update(sample_prior = 'yes', refresh=0)

#Assess priors and posteriors
msubs.brm222 |> SUYR_prior_and_posterior()

#Produce the same conditional plot but with the posteriors
msubs.brm222 |>
  conditional_effects() |> 
  plot(points=TRUE) |> 
  wrap_plots() &
  scale_y_log10()
#priors are not influential but there is very little data
```

#### MCMC sampling
```{r}
#trace plot 
msubs.brm222$fit |> stan_trace()

#border correlarion
msubs.brm222$fit |> stan_ac()

#chain convergence
msubs.brm222$fit |> stan_rhat()

#effective sample size
msubs.brm222$fit |> stan_ess() # there are no issues here

#check the densities
msubs.brm222$fit |> stan_dens(separate_chains=TRUE)
#this plot is good if we have high hats 
```

#### Model validation
```{r}
#probability check
msubs.brm222 |> pp_check(type='dens_overlay', ndraws=100) + 
  xlim(0, 5.0e+06)
#not the best fit it could be 

#sim residuals 
msubs.resids11  = make_brms_dharma_res(msubs.brm222, integerResponse= TRUE)
testUniformity(msubs.resids11)
#simulated residuals are not too bad, acceptable - deviation n.s. means no significant deviation 

#check no patterns in the residuals 
plotResiduals(msubs.resids11, quantreg = TRUE)
#no issues here, looks half decent
#the diagnostics look fine but we know we need to check other things based on the pp check
```



#### Results
```{r}
# generic summary 
msubs.brm222 |> summary() 

#thorough results
msubs.brm222 |> 
  as_draws_df() |>  
  dplyr::select(matches("^b_.*")) |> 
  exp() |> 
  summarise_draws(median, 
                  HDInterval::hdi,
                  rhat, 
                  ess_bulk,
                  Pl=~mean(.x<1), 
                  Pg=~mean(.x>1))

#There is strong evidence 99% - Pl - ((1-0.2)*100) that we have a 80% decrease in cost_km for one unit increase in GDP per capita

#the amount of variability explained by the model -quasi R sqaured
msubs.brm222 |> bayes_R2(summary=FALSE) |> median_hdci()
#we are explaining 10% of the variance with this model -  which should be a pretty good fit for the model
```
#### Plot results - predictions
```{r}
# Filter out NAs in the relevant columns
msubs_GDP <- msubs |> 
  filter(!is.na(GDP_pc))
# Generate a sequence of GDP values to predict over
gdp_seq3 <- seq(min(msubs_GDP$GDP_pc), max(msubs_GDP$GDP_pc), length.out = 100)
# Use emmeans to get the predictions on the response scale
pred_gdp3 <- emmeans(
  msubs.brm222,
  ~ GDP_pc,
  at = list(GDP_pc = gdp_seq),
  type = "response"
) |> 
  as.data.frame()

#plot
png("h7.png", width = 1400, height = 800, res = 300)
ggplot(pred_gdp3, aes(x = GDP_pc, y = response)) +
  geom_line(color = "#0072B2", size = 1) +
  geom_ribbon(aes(ymin = lower.HPD, ymax = upper.HPD), fill = "#0072B2", alpha = 0.2) +
  theme_bw() +
  theme(text = element_text(family = "serif")) +
  labs(
    x = "GDP per capita (USD)",
    y = "Maitenance cost/km²"
  ) +
  scale_y_log10()
dev.off()
```










